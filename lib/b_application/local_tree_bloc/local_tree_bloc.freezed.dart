// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'local_tree_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$LocalTreeEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocalTreeEventCopyWith<$Res> {
  factory $LocalTreeEventCopyWith(
          LocalTreeEvent value, $Res Function(LocalTreeEvent) then) =
      _$LocalTreeEventCopyWithImpl<$Res, LocalTreeEvent>;
}

/// @nodoc
class _$LocalTreeEventCopyWithImpl<$Res, $Val extends LocalTreeEvent>
    implements $LocalTreeEventCopyWith<$Res> {
  _$LocalTreeEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LoadAllTreesImplCopyWith<$Res> {
  factory _$$LoadAllTreesImplCopyWith(
          _$LoadAllTreesImpl value, $Res Function(_$LoadAllTreesImpl) then) =
      __$$LoadAllTreesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadAllTreesImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$LoadAllTreesImpl>
    implements _$$LoadAllTreesImplCopyWith<$Res> {
  __$$LoadAllTreesImplCopyWithImpl(
      _$LoadAllTreesImpl _value, $Res Function(_$LoadAllTreesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadAllTreesImpl with DiagnosticableTreeMixin implements _LoadAllTrees {
  const _$LoadAllTreesImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.loadAllTrees()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'LocalTreeEvent.loadAllTrees'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadAllTreesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return loadAllTrees();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return loadAllTrees?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (loadAllTrees != null) {
      return loadAllTrees();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return loadAllTrees(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return loadAllTrees?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (loadAllTrees != null) {
      return loadAllTrees(this);
    }
    return orElse();
  }
}

abstract class _LoadAllTrees implements LocalTreeEvent {
  const factory _LoadAllTrees() = _$LoadAllTreesImpl;
}

/// @nodoc
abstract class _$$LoadTreeImplCopyWith<$Res> {
  factory _$$LoadTreeImplCopyWith(
          _$LoadTreeImpl value, $Res Function(_$LoadTreeImpl) then) =
      __$$LoadTreeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UniqueId treeId});
}

/// @nodoc
class __$$LoadTreeImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$LoadTreeImpl>
    implements _$$LoadTreeImplCopyWith<$Res> {
  __$$LoadTreeImplCopyWithImpl(
      _$LoadTreeImpl _value, $Res Function(_$LoadTreeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? treeId = null,
  }) {
    return _then(_$LoadTreeImpl(
      treeId: null == treeId
          ? _value.treeId
          : treeId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
    ));
  }
}

/// @nodoc

class _$LoadTreeImpl with DiagnosticableTreeMixin implements _LoadTree {
  const _$LoadTreeImpl({required this.treeId});

  @override
  final UniqueId treeId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.loadTree(treeId: $treeId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.loadTree'))
      ..add(DiagnosticsProperty('treeId', treeId));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadTreeImpl &&
            (identical(other.treeId, treeId) || other.treeId == treeId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, treeId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadTreeImplCopyWith<_$LoadTreeImpl> get copyWith =>
      __$$LoadTreeImplCopyWithImpl<_$LoadTreeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return loadTree(treeId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return loadTree?.call(treeId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (loadTree != null) {
      return loadTree(treeId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return loadTree(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return loadTree?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (loadTree != null) {
      return loadTree(this);
    }
    return orElse();
  }
}

abstract class _LoadTree implements LocalTreeEvent {
  const factory _LoadTree({required final UniqueId treeId}) = _$LoadTreeImpl;

  UniqueId get treeId;
  @JsonKey(ignore: true)
  _$$LoadTreeImplCopyWith<_$LoadTreeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SelectTreeImplCopyWith<$Res> {
  factory _$$SelectTreeImplCopyWith(
          _$SelectTreeImpl value, $Res Function(_$SelectTreeImpl) then) =
      __$$SelectTreeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UniqueId treeId, UniqueId rootId});
}

/// @nodoc
class __$$SelectTreeImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$SelectTreeImpl>
    implements _$$SelectTreeImplCopyWith<$Res> {
  __$$SelectTreeImplCopyWithImpl(
      _$SelectTreeImpl _value, $Res Function(_$SelectTreeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? treeId = null,
    Object? rootId = null,
  }) {
    return _then(_$SelectTreeImpl(
      treeId: null == treeId
          ? _value.treeId
          : treeId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      rootId: null == rootId
          ? _value.rootId
          : rootId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
    ));
  }
}

/// @nodoc

class _$SelectTreeImpl with DiagnosticableTreeMixin implements _SelectTree {
  const _$SelectTreeImpl({required this.treeId, required this.rootId});

  @override
  final UniqueId treeId;
  @override
  final UniqueId rootId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.selectTree(treeId: $treeId, rootId: $rootId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.selectTree'))
      ..add(DiagnosticsProperty('treeId', treeId))
      ..add(DiagnosticsProperty('rootId', rootId));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectTreeImpl &&
            (identical(other.treeId, treeId) || other.treeId == treeId) &&
            (identical(other.rootId, rootId) || other.rootId == rootId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, treeId, rootId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SelectTreeImplCopyWith<_$SelectTreeImpl> get copyWith =>
      __$$SelectTreeImplCopyWithImpl<_$SelectTreeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return selectTree(treeId, rootId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return selectTree?.call(treeId, rootId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (selectTree != null) {
      return selectTree(treeId, rootId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return selectTree(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return selectTree?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (selectTree != null) {
      return selectTree(this);
    }
    return orElse();
  }
}

abstract class _SelectTree implements LocalTreeEvent {
  const factory _SelectTree(
      {required final UniqueId treeId,
      required final UniqueId rootId}) = _$SelectTreeImpl;

  UniqueId get treeId;
  UniqueId get rootId;
  @JsonKey(ignore: true)
  _$$SelectTreeImplCopyWith<_$SelectTreeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateTreeImplCopyWith<$Res> {
  factory _$$CreateTreeImplCopyWith(
          _$CreateTreeImpl value, $Res Function(_$CreateTreeImpl) then) =
      __$$CreateTreeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Tree tree, TNode root});

  $TreeCopyWith<$Res> get tree;
  $TNodeCopyWith<$Res> get root;
}

/// @nodoc
class __$$CreateTreeImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$CreateTreeImpl>
    implements _$$CreateTreeImplCopyWith<$Res> {
  __$$CreateTreeImplCopyWithImpl(
      _$CreateTreeImpl _value, $Res Function(_$CreateTreeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tree = null,
    Object? root = null,
  }) {
    return _then(_$CreateTreeImpl(
      tree: null == tree
          ? _value.tree
          : tree // ignore: cast_nullable_to_non_nullable
              as Tree,
      root: null == root
          ? _value.root
          : root // ignore: cast_nullable_to_non_nullable
              as TNode,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TreeCopyWith<$Res> get tree {
    return $TreeCopyWith<$Res>(_value.tree, (value) {
      return _then(_value.copyWith(tree: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TNodeCopyWith<$Res> get root {
    return $TNodeCopyWith<$Res>(_value.root, (value) {
      return _then(_value.copyWith(root: value));
    });
  }
}

/// @nodoc

class _$CreateTreeImpl with DiagnosticableTreeMixin implements _CreateTree {
  const _$CreateTreeImpl({required this.tree, required this.root});

  @override
  final Tree tree;
  @override
  final TNode root;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.createTree(tree: $tree, root: $root)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.createTree'))
      ..add(DiagnosticsProperty('tree', tree))
      ..add(DiagnosticsProperty('root', root));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateTreeImpl &&
            (identical(other.tree, tree) || other.tree == tree) &&
            (identical(other.root, root) || other.root == root));
  }

  @override
  int get hashCode => Object.hash(runtimeType, tree, root);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateTreeImplCopyWith<_$CreateTreeImpl> get copyWith =>
      __$$CreateTreeImplCopyWithImpl<_$CreateTreeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return createTree(tree, root);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return createTree?.call(tree, root);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (createTree != null) {
      return createTree(tree, root);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return createTree(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return createTree?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (createTree != null) {
      return createTree(this);
    }
    return orElse();
  }
}

abstract class _CreateTree implements LocalTreeEvent {
  const factory _CreateTree(
      {required final Tree tree, required final TNode root}) = _$CreateTreeImpl;

  Tree get tree;
  TNode get root;
  @JsonKey(ignore: true)
  _$$CreateTreeImplCopyWith<_$CreateTreeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateTreeImplCopyWith<$Res> {
  factory _$$UpdateTreeImplCopyWith(
          _$UpdateTreeImpl value, $Res Function(_$UpdateTreeImpl) then) =
      __$$UpdateTreeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Tree tree});

  $TreeCopyWith<$Res> get tree;
}

/// @nodoc
class __$$UpdateTreeImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$UpdateTreeImpl>
    implements _$$UpdateTreeImplCopyWith<$Res> {
  __$$UpdateTreeImplCopyWithImpl(
      _$UpdateTreeImpl _value, $Res Function(_$UpdateTreeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tree = null,
  }) {
    return _then(_$UpdateTreeImpl(
      tree: null == tree
          ? _value.tree
          : tree // ignore: cast_nullable_to_non_nullable
              as Tree,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TreeCopyWith<$Res> get tree {
    return $TreeCopyWith<$Res>(_value.tree, (value) {
      return _then(_value.copyWith(tree: value));
    });
  }
}

/// @nodoc

class _$UpdateTreeImpl with DiagnosticableTreeMixin implements _UpdateTree {
  const _$UpdateTreeImpl({required this.tree});

  @override
  final Tree tree;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.updateTree(tree: $tree)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.updateTree'))
      ..add(DiagnosticsProperty('tree', tree));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateTreeImpl &&
            (identical(other.tree, tree) || other.tree == tree));
  }

  @override
  int get hashCode => Object.hash(runtimeType, tree);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateTreeImplCopyWith<_$UpdateTreeImpl> get copyWith =>
      __$$UpdateTreeImplCopyWithImpl<_$UpdateTreeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return updateTree(tree);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return updateTree?.call(tree);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (updateTree != null) {
      return updateTree(tree);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return updateTree(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return updateTree?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (updateTree != null) {
      return updateTree(this);
    }
    return orElse();
  }
}

abstract class _UpdateTree implements LocalTreeEvent {
  const factory _UpdateTree({required final Tree tree}) = _$UpdateTreeImpl;

  Tree get tree;
  @JsonKey(ignore: true)
  _$$UpdateTreeImplCopyWith<_$UpdateTreeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteTreeImplCopyWith<$Res> {
  factory _$$DeleteTreeImplCopyWith(
          _$DeleteTreeImpl value, $Res Function(_$DeleteTreeImpl) then) =
      __$$DeleteTreeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UniqueId treeId});
}

/// @nodoc
class __$$DeleteTreeImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$DeleteTreeImpl>
    implements _$$DeleteTreeImplCopyWith<$Res> {
  __$$DeleteTreeImplCopyWithImpl(
      _$DeleteTreeImpl _value, $Res Function(_$DeleteTreeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? treeId = null,
  }) {
    return _then(_$DeleteTreeImpl(
      treeId: null == treeId
          ? _value.treeId
          : treeId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
    ));
  }
}

/// @nodoc

class _$DeleteTreeImpl with DiagnosticableTreeMixin implements _DeleteTree {
  const _$DeleteTreeImpl({required this.treeId});

  @override
  final UniqueId treeId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.deleteTree(treeId: $treeId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.deleteTree'))
      ..add(DiagnosticsProperty('treeId', treeId));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteTreeImpl &&
            (identical(other.treeId, treeId) || other.treeId == treeId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, treeId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteTreeImplCopyWith<_$DeleteTreeImpl> get copyWith =>
      __$$DeleteTreeImplCopyWithImpl<_$DeleteTreeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return deleteTree(treeId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return deleteTree?.call(treeId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (deleteTree != null) {
      return deleteTree(treeId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return deleteTree(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return deleteTree?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (deleteTree != null) {
      return deleteTree(this);
    }
    return orElse();
  }
}

abstract class _DeleteTree implements LocalTreeEvent {
  const factory _DeleteTree({required final UniqueId treeId}) =
      _$DeleteTreeImpl;

  UniqueId get treeId;
  @JsonKey(ignore: true)
  _$$DeleteTreeImplCopyWith<_$DeleteTreeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateNodeImplCopyWith<$Res> {
  factory _$$UpdateNodeImplCopyWith(
          _$UpdateNodeImpl value, $Res Function(_$UpdateNodeImpl) then) =
      __$$UpdateNodeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TNode node});

  $TNodeCopyWith<$Res> get node;
}

/// @nodoc
class __$$UpdateNodeImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$UpdateNodeImpl>
    implements _$$UpdateNodeImplCopyWith<$Res> {
  __$$UpdateNodeImplCopyWithImpl(
      _$UpdateNodeImpl _value, $Res Function(_$UpdateNodeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? node = null,
  }) {
    return _then(_$UpdateNodeImpl(
      node: null == node
          ? _value.node
          : node // ignore: cast_nullable_to_non_nullable
              as TNode,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TNodeCopyWith<$Res> get node {
    return $TNodeCopyWith<$Res>(_value.node, (value) {
      return _then(_value.copyWith(node: value));
    });
  }
}

/// @nodoc

class _$UpdateNodeImpl with DiagnosticableTreeMixin implements _UpdateNode {
  const _$UpdateNodeImpl({required this.node});

  @override
  final TNode node;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.updateNode(node: $node)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.updateNode'))
      ..add(DiagnosticsProperty('node', node));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateNodeImpl &&
            (identical(other.node, node) || other.node == node));
  }

  @override
  int get hashCode => Object.hash(runtimeType, node);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateNodeImplCopyWith<_$UpdateNodeImpl> get copyWith =>
      __$$UpdateNodeImplCopyWithImpl<_$UpdateNodeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return updateNode(node);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return updateNode?.call(node);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (updateNode != null) {
      return updateNode(node);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return updateNode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return updateNode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (updateNode != null) {
      return updateNode(this);
    }
    return orElse();
  }
}

abstract class _UpdateNode implements LocalTreeEvent {
  const factory _UpdateNode({required final TNode node}) = _$UpdateNodeImpl;

  TNode get node;
  @JsonKey(ignore: true)
  _$$UpdateNodeImplCopyWith<_$UpdateNodeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddPartnerImplCopyWith<$Res> {
  factory _$$AddPartnerImplCopyWith(
          _$AddPartnerImpl value, $Res Function(_$AddPartnerImpl) then) =
      __$$AddPartnerImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {TNode node, List<TNode> partnersList, List<Relation> relationsList});

  $TNodeCopyWith<$Res> get node;
}

/// @nodoc
class __$$AddPartnerImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$AddPartnerImpl>
    implements _$$AddPartnerImplCopyWith<$Res> {
  __$$AddPartnerImplCopyWithImpl(
      _$AddPartnerImpl _value, $Res Function(_$AddPartnerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? node = null,
    Object? partnersList = null,
    Object? relationsList = null,
  }) {
    return _then(_$AddPartnerImpl(
      node: null == node
          ? _value.node
          : node // ignore: cast_nullable_to_non_nullable
              as TNode,
      partnersList: null == partnersList
          ? _value._partnersList
          : partnersList // ignore: cast_nullable_to_non_nullable
              as List<TNode>,
      relationsList: null == relationsList
          ? _value._relationsList
          : relationsList // ignore: cast_nullable_to_non_nullable
              as List<Relation>,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TNodeCopyWith<$Res> get node {
    return $TNodeCopyWith<$Res>(_value.node, (value) {
      return _then(_value.copyWith(node: value));
    });
  }
}

/// @nodoc

class _$AddPartnerImpl with DiagnosticableTreeMixin implements _AddPartner {
  const _$AddPartnerImpl(
      {required this.node,
      required final List<TNode> partnersList,
      required final List<Relation> relationsList})
      : _partnersList = partnersList,
        _relationsList = relationsList;

  @override
  final TNode node;
  final List<TNode> _partnersList;
  @override
  List<TNode> get partnersList {
    if (_partnersList is EqualUnmodifiableListView) return _partnersList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_partnersList);
  }

  final List<Relation> _relationsList;
  @override
  List<Relation> get relationsList {
    if (_relationsList is EqualUnmodifiableListView) return _relationsList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_relationsList);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.addPartners(node: $node, partnersList: $partnersList, relationsList: $relationsList)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.addPartners'))
      ..add(DiagnosticsProperty('node', node))
      ..add(DiagnosticsProperty('partnersList', partnersList))
      ..add(DiagnosticsProperty('relationsList', relationsList));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddPartnerImpl &&
            (identical(other.node, node) || other.node == node) &&
            const DeepCollectionEquality()
                .equals(other._partnersList, _partnersList) &&
            const DeepCollectionEquality()
                .equals(other._relationsList, _relationsList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      node,
      const DeepCollectionEquality().hash(_partnersList),
      const DeepCollectionEquality().hash(_relationsList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddPartnerImplCopyWith<_$AddPartnerImpl> get copyWith =>
      __$$AddPartnerImplCopyWithImpl<_$AddPartnerImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return addPartners(node, partnersList, relationsList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return addPartners?.call(node, partnersList, relationsList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (addPartners != null) {
      return addPartners(node, partnersList, relationsList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return addPartners(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return addPartners?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (addPartners != null) {
      return addPartners(this);
    }
    return orElse();
  }
}

abstract class _AddPartner implements LocalTreeEvent {
  const factory _AddPartner(
      {required final TNode node,
      required final List<TNode> partnersList,
      required final List<Relation> relationsList}) = _$AddPartnerImpl;

  TNode get node;
  List<TNode> get partnersList;
  List<Relation> get relationsList;
  @JsonKey(ignore: true)
  _$$AddPartnerImplCopyWith<_$AddPartnerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddExistingPartnerImplCopyWith<$Res> {
  factory _$$AddExistingPartnerImplCopyWith(_$AddExistingPartnerImpl value,
          $Res Function(_$AddExistingPartnerImpl) then) =
      __$$AddExistingPartnerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TNode node, UniqueId partnerId, Relation relation});

  $TNodeCopyWith<$Res> get node;
  $RelationCopyWith<$Res> get relation;
}

/// @nodoc
class __$$AddExistingPartnerImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$AddExistingPartnerImpl>
    implements _$$AddExistingPartnerImplCopyWith<$Res> {
  __$$AddExistingPartnerImplCopyWithImpl(_$AddExistingPartnerImpl _value,
      $Res Function(_$AddExistingPartnerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? node = null,
    Object? partnerId = null,
    Object? relation = null,
  }) {
    return _then(_$AddExistingPartnerImpl(
      node: null == node
          ? _value.node
          : node // ignore: cast_nullable_to_non_nullable
              as TNode,
      partnerId: null == partnerId
          ? _value.partnerId
          : partnerId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      relation: null == relation
          ? _value.relation
          : relation // ignore: cast_nullable_to_non_nullable
              as Relation,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TNodeCopyWith<$Res> get node {
    return $TNodeCopyWith<$Res>(_value.node, (value) {
      return _then(_value.copyWith(node: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RelationCopyWith<$Res> get relation {
    return $RelationCopyWith<$Res>(_value.relation, (value) {
      return _then(_value.copyWith(relation: value));
    });
  }
}

/// @nodoc

class _$AddExistingPartnerImpl
    with DiagnosticableTreeMixin
    implements _AddExistingPartner {
  const _$AddExistingPartnerImpl(
      {required this.node, required this.partnerId, required this.relation});

  @override
  final TNode node;
  @override
  final UniqueId partnerId;
  @override
  final Relation relation;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.addExistingPartner(node: $node, partnerId: $partnerId, relation: $relation)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.addExistingPartner'))
      ..add(DiagnosticsProperty('node', node))
      ..add(DiagnosticsProperty('partnerId', partnerId))
      ..add(DiagnosticsProperty('relation', relation));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddExistingPartnerImpl &&
            (identical(other.node, node) || other.node == node) &&
            (identical(other.partnerId, partnerId) ||
                other.partnerId == partnerId) &&
            (identical(other.relation, relation) ||
                other.relation == relation));
  }

  @override
  int get hashCode => Object.hash(runtimeType, node, partnerId, relation);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddExistingPartnerImplCopyWith<_$AddExistingPartnerImpl> get copyWith =>
      __$$AddExistingPartnerImplCopyWithImpl<_$AddExistingPartnerImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return addExistingPartner(node, partnerId, relation);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return addExistingPartner?.call(node, partnerId, relation);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (addExistingPartner != null) {
      return addExistingPartner(node, partnerId, relation);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return addExistingPartner(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return addExistingPartner?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (addExistingPartner != null) {
      return addExistingPartner(this);
    }
    return orElse();
  }
}

abstract class _AddExistingPartner implements LocalTreeEvent {
  const factory _AddExistingPartner(
      {required final TNode node,
      required final UniqueId partnerId,
      required final Relation relation}) = _$AddExistingPartnerImpl;

  TNode get node;
  UniqueId get partnerId;
  Relation get relation;
  @JsonKey(ignore: true)
  _$$AddExistingPartnerImplCopyWith<_$AddExistingPartnerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddChildImplCopyWith<$Res> {
  factory _$$AddChildImplCopyWith(
          _$AddChildImpl value, $Res Function(_$AddChildImpl) then) =
      __$$AddChildImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<TNode> children});
}

/// @nodoc
class __$$AddChildImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$AddChildImpl>
    implements _$$AddChildImplCopyWith<$Res> {
  __$$AddChildImplCopyWithImpl(
      _$AddChildImpl _value, $Res Function(_$AddChildImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? children = null,
  }) {
    return _then(_$AddChildImpl(
      children: null == children
          ? _value._children
          : children // ignore: cast_nullable_to_non_nullable
              as List<TNode>,
    ));
  }
}

/// @nodoc

class _$AddChildImpl with DiagnosticableTreeMixin implements _AddChild {
  const _$AddChildImpl({required final List<TNode> children})
      : _children = children;

  final List<TNode> _children;
  @override
  List<TNode> get children {
    if (_children is EqualUnmodifiableListView) return _children;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_children);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.addChildren(children: $children)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.addChildren'))
      ..add(DiagnosticsProperty('children', children));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddChildImpl &&
            const DeepCollectionEquality().equals(other._children, _children));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_children));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddChildImplCopyWith<_$AddChildImpl> get copyWith =>
      __$$AddChildImplCopyWithImpl<_$AddChildImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return addChildren(children);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return addChildren?.call(children);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (addChildren != null) {
      return addChildren(children);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return addChildren(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return addChildren?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (addChildren != null) {
      return addChildren(this);
    }
    return orElse();
  }
}

abstract class _AddChild implements LocalTreeEvent {
  const factory _AddChild({required final List<TNode> children}) =
      _$AddChildImpl;

  List<TNode> get children;
  @JsonKey(ignore: true)
  _$$AddChildImplCopyWith<_$AddChildImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteNodeImplCopyWith<$Res> {
  factory _$$DeleteNodeImplCopyWith(
          _$DeleteNodeImpl value, $Res Function(_$DeleteNodeImpl) then) =
      __$$DeleteNodeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UniqueId nodeId});
}

/// @nodoc
class __$$DeleteNodeImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$DeleteNodeImpl>
    implements _$$DeleteNodeImplCopyWith<$Res> {
  __$$DeleteNodeImplCopyWithImpl(
      _$DeleteNodeImpl _value, $Res Function(_$DeleteNodeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nodeId = null,
  }) {
    return _then(_$DeleteNodeImpl(
      nodeId: null == nodeId
          ? _value.nodeId
          : nodeId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
    ));
  }
}

/// @nodoc

class _$DeleteNodeImpl with DiagnosticableTreeMixin implements _DeleteNode {
  const _$DeleteNodeImpl({required this.nodeId});

  @override
  final UniqueId nodeId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.deleteNode(nodeId: $nodeId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.deleteNode'))
      ..add(DiagnosticsProperty('nodeId', nodeId));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteNodeImpl &&
            (identical(other.nodeId, nodeId) || other.nodeId == nodeId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, nodeId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteNodeImplCopyWith<_$DeleteNodeImpl> get copyWith =>
      __$$DeleteNodeImplCopyWithImpl<_$DeleteNodeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return deleteNode(nodeId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return deleteNode?.call(nodeId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (deleteNode != null) {
      return deleteNode(nodeId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return deleteNode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return deleteNode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (deleteNode != null) {
      return deleteNode(this);
    }
    return orElse();
  }
}

abstract class _DeleteNode implements LocalTreeEvent {
  const factory _DeleteNode({required final UniqueId nodeId}) =
      _$DeleteNodeImpl;

  UniqueId get nodeId;
  @JsonKey(ignore: true)
  _$$DeleteNodeImplCopyWith<_$DeleteNodeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteChildrenImplCopyWith<$Res> {
  factory _$$DeleteChildrenImplCopyWith(_$DeleteChildrenImpl value,
          $Res Function(_$DeleteChildrenImpl) then) =
      __$$DeleteChildrenImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<TNode> children});
}

/// @nodoc
class __$$DeleteChildrenImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$DeleteChildrenImpl>
    implements _$$DeleteChildrenImplCopyWith<$Res> {
  __$$DeleteChildrenImplCopyWithImpl(
      _$DeleteChildrenImpl _value, $Res Function(_$DeleteChildrenImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? children = null,
  }) {
    return _then(_$DeleteChildrenImpl(
      children: null == children
          ? _value._children
          : children // ignore: cast_nullable_to_non_nullable
              as List<TNode>,
    ));
  }
}

/// @nodoc

class _$DeleteChildrenImpl
    with DiagnosticableTreeMixin
    implements _DeleteChildren {
  const _$DeleteChildrenImpl({required final List<TNode> children})
      : _children = children;

  final List<TNode> _children;
  @override
  List<TNode> get children {
    if (_children is EqualUnmodifiableListView) return _children;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_children);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.deleteChildren(children: $children)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.deleteChildren'))
      ..add(DiagnosticsProperty('children', children));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteChildrenImpl &&
            const DeepCollectionEquality().equals(other._children, _children));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_children));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteChildrenImplCopyWith<_$DeleteChildrenImpl> get copyWith =>
      __$$DeleteChildrenImplCopyWithImpl<_$DeleteChildrenImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return deleteChildren(children);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return deleteChildren?.call(children);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (deleteChildren != null) {
      return deleteChildren(children);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return deleteChildren(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return deleteChildren?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (deleteChildren != null) {
      return deleteChildren(this);
    }
    return orElse();
  }
}

abstract class _DeleteChildren implements LocalTreeEvent {
  const factory _DeleteChildren({required final List<TNode> children}) =
      _$DeleteChildrenImpl;

  List<TNode> get children;
  @JsonKey(ignore: true)
  _$$DeleteChildrenImplCopyWith<_$DeleteChildrenImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteRelationsImplCopyWith<$Res> {
  factory _$$DeleteRelationsImplCopyWith(_$DeleteRelationsImpl value,
          $Res Function(_$DeleteRelationsImpl) then) =
      __$$DeleteRelationsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Relation> relations});
}

/// @nodoc
class __$$DeleteRelationsImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$DeleteRelationsImpl>
    implements _$$DeleteRelationsImplCopyWith<$Res> {
  __$$DeleteRelationsImplCopyWithImpl(
      _$DeleteRelationsImpl _value, $Res Function(_$DeleteRelationsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? relations = null,
  }) {
    return _then(_$DeleteRelationsImpl(
      relations: null == relations
          ? _value._relations
          : relations // ignore: cast_nullable_to_non_nullable
              as List<Relation>,
    ));
  }
}

/// @nodoc

class _$DeleteRelationsImpl
    with DiagnosticableTreeMixin
    implements _DeleteRelations {
  const _$DeleteRelationsImpl({required final List<Relation> relations})
      : _relations = relations;

  final List<Relation> _relations;
  @override
  List<Relation> get relations {
    if (_relations is EqualUnmodifiableListView) return _relations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_relations);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.deleteRelations(relations: $relations)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.deleteRelations'))
      ..add(DiagnosticsProperty('relations', relations));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteRelationsImpl &&
            const DeepCollectionEquality()
                .equals(other._relations, _relations));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_relations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteRelationsImplCopyWith<_$DeleteRelationsImpl> get copyWith =>
      __$$DeleteRelationsImplCopyWithImpl<_$DeleteRelationsImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return deleteRelations(relations);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return deleteRelations?.call(relations);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (deleteRelations != null) {
      return deleteRelations(relations);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return deleteRelations(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return deleteRelations?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (deleteRelations != null) {
      return deleteRelations(this);
    }
    return orElse();
  }
}

abstract class _DeleteRelations implements LocalTreeEvent {
  const factory _DeleteRelations({required final List<Relation> relations}) =
      _$DeleteRelationsImpl;

  List<Relation> get relations;
  @JsonKey(ignore: true)
  _$$DeleteRelationsImplCopyWith<_$DeleteRelationsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChangeFocusRootImplCopyWith<$Res> {
  factory _$$ChangeFocusRootImplCopyWith(_$ChangeFocusRootImpl value,
          $Res Function(_$ChangeFocusRootImpl) then) =
      __$$ChangeFocusRootImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UniqueId nodeId});
}

/// @nodoc
class __$$ChangeFocusRootImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$ChangeFocusRootImpl>
    implements _$$ChangeFocusRootImplCopyWith<$Res> {
  __$$ChangeFocusRootImplCopyWithImpl(
      _$ChangeFocusRootImpl _value, $Res Function(_$ChangeFocusRootImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nodeId = null,
  }) {
    return _then(_$ChangeFocusRootImpl(
      nodeId: null == nodeId
          ? _value.nodeId
          : nodeId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
    ));
  }
}

/// @nodoc

class _$ChangeFocusRootImpl
    with DiagnosticableTreeMixin
    implements _ChangeFocusRoot {
  const _$ChangeFocusRootImpl({required this.nodeId});

  @override
  final UniqueId nodeId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.changeFocusRoot(nodeId: $nodeId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.changeFocusRoot'))
      ..add(DiagnosticsProperty('nodeId', nodeId));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeFocusRootImpl &&
            (identical(other.nodeId, nodeId) || other.nodeId == nodeId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, nodeId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeFocusRootImplCopyWith<_$ChangeFocusRootImpl> get copyWith =>
      __$$ChangeFocusRootImplCopyWithImpl<_$ChangeFocusRootImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return changeFocusRoot(nodeId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return changeFocusRoot?.call(nodeId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (changeFocusRoot != null) {
      return changeFocusRoot(nodeId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return changeFocusRoot(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return changeFocusRoot?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (changeFocusRoot != null) {
      return changeFocusRoot(this);
    }
    return orElse();
  }
}

abstract class _ChangeFocusRoot implements LocalTreeEvent {
  const factory _ChangeFocusRoot({required final UniqueId nodeId}) =
      _$ChangeFocusRootImpl;

  UniqueId get nodeId;
  @JsonKey(ignore: true)
  _$$ChangeFocusRootImplCopyWith<_$ChangeFocusRootImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ResetFocusRootImplCopyWith<$Res> {
  factory _$$ResetFocusRootImplCopyWith(_$ResetFocusRootImpl value,
          $Res Function(_$ResetFocusRootImpl) then) =
      __$$ResetFocusRootImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ResetFocusRootImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$ResetFocusRootImpl>
    implements _$$ResetFocusRootImplCopyWith<$Res> {
  __$$ResetFocusRootImplCopyWithImpl(
      _$ResetFocusRootImpl _value, $Res Function(_$ResetFocusRootImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ResetFocusRootImpl
    with DiagnosticableTreeMixin
    implements _ResetFocusRoot {
  const _$ResetFocusRootImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.resetFocusRoot()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'LocalTreeEvent.resetFocusRoot'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ResetFocusRootImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return resetFocusRoot();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return resetFocusRoot?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (resetFocusRoot != null) {
      return resetFocusRoot();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return resetFocusRoot(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return resetFocusRoot?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (resetFocusRoot != null) {
      return resetFocusRoot(this);
    }
    return orElse();
  }
}

abstract class _ResetFocusRoot implements LocalTreeEvent {
  const factory _ResetFocusRoot() = _$ResetFocusRootImpl;
}

/// @nodoc
abstract class _$$ChangeGenerationLimitImplCopyWith<$Res> {
  factory _$$ChangeGenerationLimitImplCopyWith(
          _$ChangeGenerationLimitImpl value,
          $Res Function(_$ChangeGenerationLimitImpl) then) =
      __$$ChangeGenerationLimitImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int generations});
}

/// @nodoc
class __$$ChangeGenerationLimitImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$ChangeGenerationLimitImpl>
    implements _$$ChangeGenerationLimitImplCopyWith<$Res> {
  __$$ChangeGenerationLimitImplCopyWithImpl(_$ChangeGenerationLimitImpl _value,
      $Res Function(_$ChangeGenerationLimitImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? generations = null,
  }) {
    return _then(_$ChangeGenerationLimitImpl(
      generations: null == generations
          ? _value.generations
          : generations // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ChangeGenerationLimitImpl
    with DiagnosticableTreeMixin
    implements _ChangeGenerationLimit {
  const _$ChangeGenerationLimitImpl({required this.generations});

  @override
  final int generations;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.changeGenerationLimit(generations: $generations)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.changeGenerationLimit'))
      ..add(DiagnosticsProperty('generations', generations));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeGenerationLimitImpl &&
            (identical(other.generations, generations) ||
                other.generations == generations));
  }

  @override
  int get hashCode => Object.hash(runtimeType, generations);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeGenerationLimitImplCopyWith<_$ChangeGenerationLimitImpl>
      get copyWith => __$$ChangeGenerationLimitImplCopyWithImpl<
          _$ChangeGenerationLimitImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return changeGenerationLimit(generations);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return changeGenerationLimit?.call(generations);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (changeGenerationLimit != null) {
      return changeGenerationLimit(generations);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return changeGenerationLimit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return changeGenerationLimit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (changeGenerationLimit != null) {
      return changeGenerationLimit(this);
    }
    return orElse();
  }
}

abstract class _ChangeGenerationLimit implements LocalTreeEvent {
  const factory _ChangeGenerationLimit({required final int generations}) =
      _$ChangeGenerationLimitImpl;

  int get generations;
  @JsonKey(ignore: true)
  _$$ChangeGenerationLimitImplCopyWith<_$ChangeGenerationLimitImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ToggleShowUnknownImplCopyWith<$Res> {
  factory _$$ToggleShowUnknownImplCopyWith(_$ToggleShowUnknownImpl value,
          $Res Function(_$ToggleShowUnknownImpl) then) =
      __$$ToggleShowUnknownImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool show});
}

/// @nodoc
class __$$ToggleShowUnknownImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$ToggleShowUnknownImpl>
    implements _$$ToggleShowUnknownImplCopyWith<$Res> {
  __$$ToggleShowUnknownImplCopyWithImpl(_$ToggleShowUnknownImpl _value,
      $Res Function(_$ToggleShowUnknownImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? show = null,
  }) {
    return _then(_$ToggleShowUnknownImpl(
      show: null == show
          ? _value.show
          : show // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ToggleShowUnknownImpl
    with DiagnosticableTreeMixin
    implements _ToggleShowUnknown {
  const _$ToggleShowUnknownImpl({required this.show});

  @override
  final bool show;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.toggleShowUnknown(show: $show)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.toggleShowUnknown'))
      ..add(DiagnosticsProperty('show', show));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ToggleShowUnknownImpl &&
            (identical(other.show, show) || other.show == show));
  }

  @override
  int get hashCode => Object.hash(runtimeType, show);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ToggleShowUnknownImplCopyWith<_$ToggleShowUnknownImpl> get copyWith =>
      __$$ToggleShowUnknownImplCopyWithImpl<_$ToggleShowUnknownImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return toggleShowUnknown(show);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return toggleShowUnknown?.call(show);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (toggleShowUnknown != null) {
      return toggleShowUnknown(show);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return toggleShowUnknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return toggleShowUnknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (toggleShowUnknown != null) {
      return toggleShowUnknown(this);
    }
    return orElse();
  }
}

abstract class _ToggleShowUnknown implements LocalTreeEvent {
  const factory _ToggleShowUnknown({required final bool show}) =
      _$ToggleShowUnknownImpl;

  bool get show;
  @JsonKey(ignore: true)
  _$$ToggleShowUnknownImplCopyWith<_$ToggleShowUnknownImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SyncFinishedImplCopyWith<$Res> {
  factory _$$SyncFinishedImplCopyWith(
          _$SyncFinishedImpl value, $Res Function(_$SyncFinishedImpl) then) =
      __$$SyncFinishedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool success, int pendingSyncCount});
}

/// @nodoc
class __$$SyncFinishedImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$SyncFinishedImpl>
    implements _$$SyncFinishedImplCopyWith<$Res> {
  __$$SyncFinishedImplCopyWithImpl(
      _$SyncFinishedImpl _value, $Res Function(_$SyncFinishedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? success = null,
    Object? pendingSyncCount = null,
  }) {
    return _then(_$SyncFinishedImpl(
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      pendingSyncCount: null == pendingSyncCount
          ? _value.pendingSyncCount
          : pendingSyncCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SyncFinishedImpl with DiagnosticableTreeMixin implements _SyncFinished {
  const _$SyncFinishedImpl(
      {required this.success, required this.pendingSyncCount});

  @override
  final bool success;
  @override
  final int pendingSyncCount;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.syncFinished(success: $success, pendingSyncCount: $pendingSyncCount)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.syncFinished'))
      ..add(DiagnosticsProperty('success', success))
      ..add(DiagnosticsProperty('pendingSyncCount', pendingSyncCount));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SyncFinishedImpl &&
            (identical(other.success, success) || other.success == success) &&
            (identical(other.pendingSyncCount, pendingSyncCount) ||
                other.pendingSyncCount == pendingSyncCount));
  }

  @override
  int get hashCode => Object.hash(runtimeType, success, pendingSyncCount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SyncFinishedImplCopyWith<_$SyncFinishedImpl> get copyWith =>
      __$$SyncFinishedImplCopyWithImpl<_$SyncFinishedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return syncFinished(success, pendingSyncCount);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return syncFinished?.call(success, pendingSyncCount);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (syncFinished != null) {
      return syncFinished(success, pendingSyncCount);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return syncFinished(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return syncFinished?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (syncFinished != null) {
      return syncFinished(this);
    }
    return orElse();
  }
}

abstract class _SyncFinished implements LocalTreeEvent {
  const factory _SyncFinished(
      {required final bool success,
      required final int pendingSyncCount}) = _$SyncFinishedImpl;

  bool get success;
  int get pendingSyncCount;
  @JsonKey(ignore: true)
  _$$SyncFinishedImplCopyWith<_$SyncFinishedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SearchTreeImplCopyWith<$Res> {
  factory _$$SearchTreeImplCopyWith(
          _$SearchTreeImpl value, $Res Function(_$SearchTreeImpl) then) =
      __$$SearchTreeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UniqueId nodeId});
}

/// @nodoc
class __$$SearchTreeImplCopyWithImpl<$Res>
    extends _$LocalTreeEventCopyWithImpl<$Res, _$SearchTreeImpl>
    implements _$$SearchTreeImplCopyWith<$Res> {
  __$$SearchTreeImplCopyWithImpl(
      _$SearchTreeImpl _value, $Res Function(_$SearchTreeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nodeId = null,
  }) {
    return _then(_$SearchTreeImpl(
      nodeId: null == nodeId
          ? _value.nodeId
          : nodeId // ignore: cast_nullable_to_non_nullable
              as UniqueId,
    ));
  }
}

/// @nodoc

class _$SearchTreeImpl with DiagnosticableTreeMixin implements _SearchTree {
  const _$SearchTreeImpl({required this.nodeId});

  @override
  final UniqueId nodeId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeEvent.searchTree(nodeId: $nodeId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeEvent.searchTree'))
      ..add(DiagnosticsProperty('nodeId', nodeId));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchTreeImpl &&
            (identical(other.nodeId, nodeId) || other.nodeId == nodeId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, nodeId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchTreeImplCopyWith<_$SearchTreeImpl> get copyWith =>
      __$$SearchTreeImplCopyWithImpl<_$SearchTreeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAllTrees,
    required TResult Function(UniqueId treeId) loadTree,
    required TResult Function(UniqueId treeId, UniqueId rootId) selectTree,
    required TResult Function(Tree tree, TNode root) createTree,
    required TResult Function(Tree tree) updateTree,
    required TResult Function(UniqueId treeId) deleteTree,
    required TResult Function(TNode node) updateNode,
    required TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)
        addPartners,
    required TResult Function(TNode node, UniqueId partnerId, Relation relation)
        addExistingPartner,
    required TResult Function(List<TNode> children) addChildren,
    required TResult Function(UniqueId nodeId) deleteNode,
    required TResult Function(List<TNode> children) deleteChildren,
    required TResult Function(List<Relation> relations) deleteRelations,
    required TResult Function(UniqueId nodeId) changeFocusRoot,
    required TResult Function() resetFocusRoot,
    required TResult Function(int generations) changeGenerationLimit,
    required TResult Function(bool show) toggleShowUnknown,
    required TResult Function(bool success, int pendingSyncCount) syncFinished,
    required TResult Function(UniqueId nodeId) searchTree,
  }) {
    return searchTree(nodeId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAllTrees,
    TResult? Function(UniqueId treeId)? loadTree,
    TResult? Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult? Function(Tree tree, TNode root)? createTree,
    TResult? Function(Tree tree)? updateTree,
    TResult? Function(UniqueId treeId)? deleteTree,
    TResult? Function(TNode node)? updateNode,
    TResult? Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult? Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult? Function(List<TNode> children)? addChildren,
    TResult? Function(UniqueId nodeId)? deleteNode,
    TResult? Function(List<TNode> children)? deleteChildren,
    TResult? Function(List<Relation> relations)? deleteRelations,
    TResult? Function(UniqueId nodeId)? changeFocusRoot,
    TResult? Function()? resetFocusRoot,
    TResult? Function(int generations)? changeGenerationLimit,
    TResult? Function(bool show)? toggleShowUnknown,
    TResult? Function(bool success, int pendingSyncCount)? syncFinished,
    TResult? Function(UniqueId nodeId)? searchTree,
  }) {
    return searchTree?.call(nodeId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAllTrees,
    TResult Function(UniqueId treeId)? loadTree,
    TResult Function(UniqueId treeId, UniqueId rootId)? selectTree,
    TResult Function(Tree tree, TNode root)? createTree,
    TResult Function(Tree tree)? updateTree,
    TResult Function(UniqueId treeId)? deleteTree,
    TResult Function(TNode node)? updateNode,
    TResult Function(
            TNode node, List<TNode> partnersList, List<Relation> relationsList)?
        addPartners,
    TResult Function(TNode node, UniqueId partnerId, Relation relation)?
        addExistingPartner,
    TResult Function(List<TNode> children)? addChildren,
    TResult Function(UniqueId nodeId)? deleteNode,
    TResult Function(List<TNode> children)? deleteChildren,
    TResult Function(List<Relation> relations)? deleteRelations,
    TResult Function(UniqueId nodeId)? changeFocusRoot,
    TResult Function()? resetFocusRoot,
    TResult Function(int generations)? changeGenerationLimit,
    TResult Function(bool show)? toggleShowUnknown,
    TResult Function(bool success, int pendingSyncCount)? syncFinished,
    TResult Function(UniqueId nodeId)? searchTree,
    required TResult orElse(),
  }) {
    if (searchTree != null) {
      return searchTree(nodeId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAllTrees value) loadAllTrees,
    required TResult Function(_LoadTree value) loadTree,
    required TResult Function(_SelectTree value) selectTree,
    required TResult Function(_CreateTree value) createTree,
    required TResult Function(_UpdateTree value) updateTree,
    required TResult Function(_DeleteTree value) deleteTree,
    required TResult Function(_UpdateNode value) updateNode,
    required TResult Function(_AddPartner value) addPartners,
    required TResult Function(_AddExistingPartner value) addExistingPartner,
    required TResult Function(_AddChild value) addChildren,
    required TResult Function(_DeleteNode value) deleteNode,
    required TResult Function(_DeleteChildren value) deleteChildren,
    required TResult Function(_DeleteRelations value) deleteRelations,
    required TResult Function(_ChangeFocusRoot value) changeFocusRoot,
    required TResult Function(_ResetFocusRoot value) resetFocusRoot,
    required TResult Function(_ChangeGenerationLimit value)
        changeGenerationLimit,
    required TResult Function(_ToggleShowUnknown value) toggleShowUnknown,
    required TResult Function(_SyncFinished value) syncFinished,
    required TResult Function(_SearchTree value) searchTree,
  }) {
    return searchTree(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAllTrees value)? loadAllTrees,
    TResult? Function(_LoadTree value)? loadTree,
    TResult? Function(_SelectTree value)? selectTree,
    TResult? Function(_CreateTree value)? createTree,
    TResult? Function(_UpdateTree value)? updateTree,
    TResult? Function(_DeleteTree value)? deleteTree,
    TResult? Function(_UpdateNode value)? updateNode,
    TResult? Function(_AddPartner value)? addPartners,
    TResult? Function(_AddExistingPartner value)? addExistingPartner,
    TResult? Function(_AddChild value)? addChildren,
    TResult? Function(_DeleteNode value)? deleteNode,
    TResult? Function(_DeleteChildren value)? deleteChildren,
    TResult? Function(_DeleteRelations value)? deleteRelations,
    TResult? Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult? Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult? Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult? Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult? Function(_SyncFinished value)? syncFinished,
    TResult? Function(_SearchTree value)? searchTree,
  }) {
    return searchTree?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAllTrees value)? loadAllTrees,
    TResult Function(_LoadTree value)? loadTree,
    TResult Function(_SelectTree value)? selectTree,
    TResult Function(_CreateTree value)? createTree,
    TResult Function(_UpdateTree value)? updateTree,
    TResult Function(_DeleteTree value)? deleteTree,
    TResult Function(_UpdateNode value)? updateNode,
    TResult Function(_AddPartner value)? addPartners,
    TResult Function(_AddExistingPartner value)? addExistingPartner,
    TResult Function(_AddChild value)? addChildren,
    TResult Function(_DeleteNode value)? deleteNode,
    TResult Function(_DeleteChildren value)? deleteChildren,
    TResult Function(_DeleteRelations value)? deleteRelations,
    TResult Function(_ChangeFocusRoot value)? changeFocusRoot,
    TResult Function(_ResetFocusRoot value)? resetFocusRoot,
    TResult Function(_ChangeGenerationLimit value)? changeGenerationLimit,
    TResult Function(_ToggleShowUnknown value)? toggleShowUnknown,
    TResult Function(_SyncFinished value)? syncFinished,
    TResult Function(_SearchTree value)? searchTree,
    required TResult orElse(),
  }) {
    if (searchTree != null) {
      return searchTree(this);
    }
    return orElse();
  }
}

abstract class _SearchTree implements LocalTreeEvent {
  const factory _SearchTree({required final UniqueId nodeId}) =
      _$SearchTreeImpl;

  UniqueId get nodeId;
  @JsonKey(ignore: true)
  _$$SearchTreeImplCopyWith<_$SearchTreeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LocalTreeState {
// Loading flags
  bool get isLoadingTrees => throw _privateConstructorUsedError;
  bool get isLoadingTree => throw _privateConstructorUsedError;
  int get pendingSyncCount =>
      throw _privateConstructorUsedError; // Trees list + selection
  List<Tree> get trees => throw _privateConstructorUsedError;
  UniqueId? get selectedTreeId =>
      throw _privateConstructorUsedError; // Root / focus ids
  UniqueId? get mainRootId => throw _privateConstructorUsedError;
  UniqueId? get focusRootId =>
      throw _privateConstructorUsedError; // Canonical normalized store
  TreeGraphStore get store =>
      throw _privateConstructorUsedError; // tree settings
  TreeSettings? get settings =>
      throw _privateConstructorUsedError; // Failures + sync status
  Option<bool> get lastSyncSuccess => throw _privateConstructorUsedError;
  Option<TreeFailure> get treeFailureOption =>
      throw _privateConstructorUsedError;
  Option<TNodeFailure> get nodeFailureOption =>
      throw _privateConstructorUsedError;
  Option<RelationFailure> get relationFailureOption =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LocalTreeStateCopyWith<LocalTreeState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocalTreeStateCopyWith<$Res> {
  factory $LocalTreeStateCopyWith(
          LocalTreeState value, $Res Function(LocalTreeState) then) =
      _$LocalTreeStateCopyWithImpl<$Res, LocalTreeState>;
  @useResult
  $Res call(
      {bool isLoadingTrees,
      bool isLoadingTree,
      int pendingSyncCount,
      List<Tree> trees,
      UniqueId? selectedTreeId,
      UniqueId? mainRootId,
      UniqueId? focusRootId,
      TreeGraphStore store,
      TreeSettings? settings,
      Option<bool> lastSyncSuccess,
      Option<TreeFailure> treeFailureOption,
      Option<TNodeFailure> nodeFailureOption,
      Option<RelationFailure> relationFailureOption});

  $TreeSettingsCopyWith<$Res>? get settings;
}

/// @nodoc
class _$LocalTreeStateCopyWithImpl<$Res, $Val extends LocalTreeState>
    implements $LocalTreeStateCopyWith<$Res> {
  _$LocalTreeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoadingTrees = null,
    Object? isLoadingTree = null,
    Object? pendingSyncCount = null,
    Object? trees = null,
    Object? selectedTreeId = freezed,
    Object? mainRootId = freezed,
    Object? focusRootId = freezed,
    Object? store = null,
    Object? settings = freezed,
    Object? lastSyncSuccess = null,
    Object? treeFailureOption = null,
    Object? nodeFailureOption = null,
    Object? relationFailureOption = null,
  }) {
    return _then(_value.copyWith(
      isLoadingTrees: null == isLoadingTrees
          ? _value.isLoadingTrees
          : isLoadingTrees // ignore: cast_nullable_to_non_nullable
              as bool,
      isLoadingTree: null == isLoadingTree
          ? _value.isLoadingTree
          : isLoadingTree // ignore: cast_nullable_to_non_nullable
              as bool,
      pendingSyncCount: null == pendingSyncCount
          ? _value.pendingSyncCount
          : pendingSyncCount // ignore: cast_nullable_to_non_nullable
              as int,
      trees: null == trees
          ? _value.trees
          : trees // ignore: cast_nullable_to_non_nullable
              as List<Tree>,
      selectedTreeId: freezed == selectedTreeId
          ? _value.selectedTreeId
          : selectedTreeId // ignore: cast_nullable_to_non_nullable
              as UniqueId?,
      mainRootId: freezed == mainRootId
          ? _value.mainRootId
          : mainRootId // ignore: cast_nullable_to_non_nullable
              as UniqueId?,
      focusRootId: freezed == focusRootId
          ? _value.focusRootId
          : focusRootId // ignore: cast_nullable_to_non_nullable
              as UniqueId?,
      store: null == store
          ? _value.store
          : store // ignore: cast_nullable_to_non_nullable
              as TreeGraphStore,
      settings: freezed == settings
          ? _value.settings
          : settings // ignore: cast_nullable_to_non_nullable
              as TreeSettings?,
      lastSyncSuccess: null == lastSyncSuccess
          ? _value.lastSyncSuccess
          : lastSyncSuccess // ignore: cast_nullable_to_non_nullable
              as Option<bool>,
      treeFailureOption: null == treeFailureOption
          ? _value.treeFailureOption
          : treeFailureOption // ignore: cast_nullable_to_non_nullable
              as Option<TreeFailure>,
      nodeFailureOption: null == nodeFailureOption
          ? _value.nodeFailureOption
          : nodeFailureOption // ignore: cast_nullable_to_non_nullable
              as Option<TNodeFailure>,
      relationFailureOption: null == relationFailureOption
          ? _value.relationFailureOption
          : relationFailureOption // ignore: cast_nullable_to_non_nullable
              as Option<RelationFailure>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TreeSettingsCopyWith<$Res>? get settings {
    if (_value.settings == null) {
      return null;
    }

    return $TreeSettingsCopyWith<$Res>(_value.settings!, (value) {
      return _then(_value.copyWith(settings: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LocalTreeStateImplCopyWith<$Res>
    implements $LocalTreeStateCopyWith<$Res> {
  factory _$$LocalTreeStateImplCopyWith(_$LocalTreeStateImpl value,
          $Res Function(_$LocalTreeStateImpl) then) =
      __$$LocalTreeStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isLoadingTrees,
      bool isLoadingTree,
      int pendingSyncCount,
      List<Tree> trees,
      UniqueId? selectedTreeId,
      UniqueId? mainRootId,
      UniqueId? focusRootId,
      TreeGraphStore store,
      TreeSettings? settings,
      Option<bool> lastSyncSuccess,
      Option<TreeFailure> treeFailureOption,
      Option<TNodeFailure> nodeFailureOption,
      Option<RelationFailure> relationFailureOption});

  @override
  $TreeSettingsCopyWith<$Res>? get settings;
}

/// @nodoc
class __$$LocalTreeStateImplCopyWithImpl<$Res>
    extends _$LocalTreeStateCopyWithImpl<$Res, _$LocalTreeStateImpl>
    implements _$$LocalTreeStateImplCopyWith<$Res> {
  __$$LocalTreeStateImplCopyWithImpl(
      _$LocalTreeStateImpl _value, $Res Function(_$LocalTreeStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoadingTrees = null,
    Object? isLoadingTree = null,
    Object? pendingSyncCount = null,
    Object? trees = null,
    Object? selectedTreeId = freezed,
    Object? mainRootId = freezed,
    Object? focusRootId = freezed,
    Object? store = null,
    Object? settings = freezed,
    Object? lastSyncSuccess = null,
    Object? treeFailureOption = null,
    Object? nodeFailureOption = null,
    Object? relationFailureOption = null,
  }) {
    return _then(_$LocalTreeStateImpl(
      isLoadingTrees: null == isLoadingTrees
          ? _value.isLoadingTrees
          : isLoadingTrees // ignore: cast_nullable_to_non_nullable
              as bool,
      isLoadingTree: null == isLoadingTree
          ? _value.isLoadingTree
          : isLoadingTree // ignore: cast_nullable_to_non_nullable
              as bool,
      pendingSyncCount: null == pendingSyncCount
          ? _value.pendingSyncCount
          : pendingSyncCount // ignore: cast_nullable_to_non_nullable
              as int,
      trees: null == trees
          ? _value._trees
          : trees // ignore: cast_nullable_to_non_nullable
              as List<Tree>,
      selectedTreeId: freezed == selectedTreeId
          ? _value.selectedTreeId
          : selectedTreeId // ignore: cast_nullable_to_non_nullable
              as UniqueId?,
      mainRootId: freezed == mainRootId
          ? _value.mainRootId
          : mainRootId // ignore: cast_nullable_to_non_nullable
              as UniqueId?,
      focusRootId: freezed == focusRootId
          ? _value.focusRootId
          : focusRootId // ignore: cast_nullable_to_non_nullable
              as UniqueId?,
      store: null == store
          ? _value.store
          : store // ignore: cast_nullable_to_non_nullable
              as TreeGraphStore,
      settings: freezed == settings
          ? _value.settings
          : settings // ignore: cast_nullable_to_non_nullable
              as TreeSettings?,
      lastSyncSuccess: null == lastSyncSuccess
          ? _value.lastSyncSuccess
          : lastSyncSuccess // ignore: cast_nullable_to_non_nullable
              as Option<bool>,
      treeFailureOption: null == treeFailureOption
          ? _value.treeFailureOption
          : treeFailureOption // ignore: cast_nullable_to_non_nullable
              as Option<TreeFailure>,
      nodeFailureOption: null == nodeFailureOption
          ? _value.nodeFailureOption
          : nodeFailureOption // ignore: cast_nullable_to_non_nullable
              as Option<TNodeFailure>,
      relationFailureOption: null == relationFailureOption
          ? _value.relationFailureOption
          : relationFailureOption // ignore: cast_nullable_to_non_nullable
              as Option<RelationFailure>,
    ));
  }
}

/// @nodoc

class _$LocalTreeStateImpl
    with DiagnosticableTreeMixin
    implements _LocalTreeState {
  const _$LocalTreeStateImpl(
      {required this.isLoadingTrees,
      required this.isLoadingTree,
      required this.pendingSyncCount,
      required final List<Tree> trees,
      required this.selectedTreeId,
      required this.mainRootId,
      required this.focusRootId,
      required this.store,
      required this.settings,
      required this.lastSyncSuccess,
      required this.treeFailureOption,
      required this.nodeFailureOption,
      required this.relationFailureOption})
      : _trees = trees;

// Loading flags
  @override
  final bool isLoadingTrees;
  @override
  final bool isLoadingTree;
  @override
  final int pendingSyncCount;
// Trees list + selection
  final List<Tree> _trees;
// Trees list + selection
  @override
  List<Tree> get trees {
    if (_trees is EqualUnmodifiableListView) return _trees;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_trees);
  }

  @override
  final UniqueId? selectedTreeId;
// Root / focus ids
  @override
  final UniqueId? mainRootId;
  @override
  final UniqueId? focusRootId;
// Canonical normalized store
  @override
  final TreeGraphStore store;
// tree settings
  @override
  final TreeSettings? settings;
// Failures + sync status
  @override
  final Option<bool> lastSyncSuccess;
  @override
  final Option<TreeFailure> treeFailureOption;
  @override
  final Option<TNodeFailure> nodeFailureOption;
  @override
  final Option<RelationFailure> relationFailureOption;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalTreeState(isLoadingTrees: $isLoadingTrees, isLoadingTree: $isLoadingTree, pendingSyncCount: $pendingSyncCount, trees: $trees, selectedTreeId: $selectedTreeId, mainRootId: $mainRootId, focusRootId: $focusRootId, store: $store, settings: $settings, lastSyncSuccess: $lastSyncSuccess, treeFailureOption: $treeFailureOption, nodeFailureOption: $nodeFailureOption, relationFailureOption: $relationFailureOption)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LocalTreeState'))
      ..add(DiagnosticsProperty('isLoadingTrees', isLoadingTrees))
      ..add(DiagnosticsProperty('isLoadingTree', isLoadingTree))
      ..add(DiagnosticsProperty('pendingSyncCount', pendingSyncCount))
      ..add(DiagnosticsProperty('trees', trees))
      ..add(DiagnosticsProperty('selectedTreeId', selectedTreeId))
      ..add(DiagnosticsProperty('mainRootId', mainRootId))
      ..add(DiagnosticsProperty('focusRootId', focusRootId))
      ..add(DiagnosticsProperty('store', store))
      ..add(DiagnosticsProperty('settings', settings))
      ..add(DiagnosticsProperty('lastSyncSuccess', lastSyncSuccess))
      ..add(DiagnosticsProperty('treeFailureOption', treeFailureOption))
      ..add(DiagnosticsProperty('nodeFailureOption', nodeFailureOption))
      ..add(
          DiagnosticsProperty('relationFailureOption', relationFailureOption));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LocalTreeStateImpl &&
            (identical(other.isLoadingTrees, isLoadingTrees) ||
                other.isLoadingTrees == isLoadingTrees) &&
            (identical(other.isLoadingTree, isLoadingTree) ||
                other.isLoadingTree == isLoadingTree) &&
            (identical(other.pendingSyncCount, pendingSyncCount) ||
                other.pendingSyncCount == pendingSyncCount) &&
            const DeepCollectionEquality().equals(other._trees, _trees) &&
            (identical(other.selectedTreeId, selectedTreeId) ||
                other.selectedTreeId == selectedTreeId) &&
            (identical(other.mainRootId, mainRootId) ||
                other.mainRootId == mainRootId) &&
            (identical(other.focusRootId, focusRootId) ||
                other.focusRootId == focusRootId) &&
            (identical(other.store, store) || other.store == store) &&
            (identical(other.settings, settings) ||
                other.settings == settings) &&
            (identical(other.lastSyncSuccess, lastSyncSuccess) ||
                other.lastSyncSuccess == lastSyncSuccess) &&
            (identical(other.treeFailureOption, treeFailureOption) ||
                other.treeFailureOption == treeFailureOption) &&
            (identical(other.nodeFailureOption, nodeFailureOption) ||
                other.nodeFailureOption == nodeFailureOption) &&
            (identical(other.relationFailureOption, relationFailureOption) ||
                other.relationFailureOption == relationFailureOption));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isLoadingTrees,
      isLoadingTree,
      pendingSyncCount,
      const DeepCollectionEquality().hash(_trees),
      selectedTreeId,
      mainRootId,
      focusRootId,
      store,
      settings,
      lastSyncSuccess,
      treeFailureOption,
      nodeFailureOption,
      relationFailureOption);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LocalTreeStateImplCopyWith<_$LocalTreeStateImpl> get copyWith =>
      __$$LocalTreeStateImplCopyWithImpl<_$LocalTreeStateImpl>(
          this, _$identity);
}

abstract class _LocalTreeState implements LocalTreeState {
  const factory _LocalTreeState(
          {required final bool isLoadingTrees,
          required final bool isLoadingTree,
          required final int pendingSyncCount,
          required final List<Tree> trees,
          required final UniqueId? selectedTreeId,
          required final UniqueId? mainRootId,
          required final UniqueId? focusRootId,
          required final TreeGraphStore store,
          required final TreeSettings? settings,
          required final Option<bool> lastSyncSuccess,
          required final Option<TreeFailure> treeFailureOption,
          required final Option<TNodeFailure> nodeFailureOption,
          required final Option<RelationFailure> relationFailureOption}) =
      _$LocalTreeStateImpl;

  @override // Loading flags
  bool get isLoadingTrees;
  @override
  bool get isLoadingTree;
  @override
  int get pendingSyncCount;
  @override // Trees list + selection
  List<Tree> get trees;
  @override
  UniqueId? get selectedTreeId;
  @override // Root / focus ids
  UniqueId? get mainRootId;
  @override
  UniqueId? get focusRootId;
  @override // Canonical normalized store
  TreeGraphStore get store;
  @override // tree settings
  TreeSettings? get settings;
  @override // Failures + sync status
  Option<bool> get lastSyncSuccess;
  @override
  Option<TreeFailure> get treeFailureOption;
  @override
  Option<TNodeFailure> get nodeFailureOption;
  @override
  Option<RelationFailure> get relationFailureOption;
  @override
  @JsonKey(ignore: true)
  _$$LocalTreeStateImplCopyWith<_$LocalTreeStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
